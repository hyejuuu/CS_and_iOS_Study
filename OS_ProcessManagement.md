#### 프로세스 생성

- 부모 프로세스가 자식 프로세스를 생성한다.

- 프로세스는 자원을 필요로 한다. 이 자원은 OS에서 받거나 부모와 공유해서 얻는다.

  --> 원칙적으로 프로세스가 생성되면 부모 프로세스가 별도의 프로세스와 마찬가지이기 때문에 자원을 공유하지 않는 경우가 일반적이다.

- 수행

  - 부모와 자식이 공존하며 수행되는 모델
  - 자식이 terminate될 때까지 부모가 wait하는 모델

- 주소 공간

  1. 자식은 부모 공간을 그대로 복사한다. (PCB나 자원도 복사) -> fork()

  2. 그 공간에 새로운 프로그램을 덮어씌운다. -> exec()

     이런 식으로 서로 다른 프로그램들이 존재할 수 있는 것이다.



<br>



#### 프로세스 종료

- 보통 프로세스가 종료될 때 프로세스는 exit이라는 시스템콜을 호출한다. 그러면 프로세스가 종료될 때 자식이 부모에게 wait 시스템콜을 통해서 데이터를 전달하게되고 종료된 프로세스의 각종 자원들이 OS에 반납된다.
- 부모 프로세스가 abort로 자식의 수행을 종료되는 경우가 있다.
  - 자식이 할당 자원의 한계치를 넘어서는 경우
  - 자식에게 할당된 task가 더 이상 필요하지 않은 경우
  - 부모가 exit되는 경우 --> OS는 부모 프로세스가 종료되는 경우 부모 프로세스의 자식들이 더 이상 실행되지 않도록 모두 종료시킨다.



<br>

#### fork() 시스템콜

fork()를 하면 자신을 복사해 자식 프로세스 하나를 생성한다.

부모 프로세스의 문맥까지 복사하기 때문에 PC로 부모 프로세스와 동일하다 그렇기 때문에 자식 프로세스도 fork()가 발생한 시점부터 실행하게된다.

fork()는 프로세스를 구분하기 위해서 부모프로세스라면 return value(pid)를 양수값, 자식 프로세스라면 0을 반환한다.



<br>

#### exec() 시스템콜

exec()는 어떠한 프로그램을 완전히 새로운 프로세스로 덮어씌워 주는 역할을 한다.

--> 그렇기 때문에 fork()와는 달리 프로그램의 시작부분부터 실행한다.



<br>

#### wait() 시스템콜

wait() 시스템콜을 호출하면 커널은 프로세스 A를 sleep시켜 blocked 상태로 만들고 자식 프로세스가 종료되면 커널이 다시 프로세스 A를 깨워서 Ready 상태로 만든다.



<br>

#### exit() 시스템콜

exit() 시스템콜을 호출하면 프로세스가 종료된다.

- 자발적 종료 : 마지막 코드 수행 후 프로그램에 명시적으로 적어주지 않아도 main 함수가 return되는 시점에 exit()를 컴파일러가 추가해준다.
- 비자발적 종료 : 외부적인 요인에 의한 종료
  - 부모 프로세스가 자식 프로세스를 강제 종료시키는 경우 (자식 프로세스가 자원의 한계치를 초과해서 요청 / 자식에게 할당된 테스트가 더 이상 필요하지 않을 때)
  - 키보드로 kill, break 등을 친 경우
  - 부모 프로세스가 종료되는 경우 (부모 프로세스는 종료되기 전에 자식 프로세스들을 먼저 종료시킨다.)



<br>

#### 프로세스 간 협력

- 독립적 프로세스 : 일반적으로 프로세스는 각자의 주소 공간을 가지고 수행되므로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 않는다.
- 협력 프로세스 : 경우에 따라서 프로세스가 서로 데이터를 주고 받으며 실행될 수 있다.



- 프로세스 간 협력 메커니즘 (IPC: Interprocess Communication)

  - Message passing

    - 프로세스 A가 프로세스 B에게 메시지를 전달하고 그 메시지를 통해서 프로세스 B가 수행되는 방식 ( 프로세스는 완전히 독립적이기 때문에 서로 직접적으로는 메시지를 전달할 수 없다. 그렇기 때문에 항상 커널을 통해서 메시지를 전달할 수 있다.)

    - 프로세스 사이에 공유 변수(shared variable)를 전혀 사용하지 않고 통신하는 시스템이다.

      - Direct Communication : 통신하려는 프로세스의 이름을 명시적으로 표시

        <img width="569" alt="directCommunication" src="https://user-images.githubusercontent.com/34293225/68068535-2e4afa00-fd99-11e9-826b-d6dd08883c8d.png">

      - Indirect Communication : mailbox 또는 port를 통해 메시지를 간접적으로 전달

        - 한정된 프로세스로 명시해준 것이 아니기 때문에 아무 프로세스나 메시지를 가져갈 수 있다.

        <img width="667" alt="indirectCommunication" src="https://user-images.githubusercontent.com/34293225/68068553-60f4f280-fd99-11e9-8a02-01b705d30f44.png">

        <img width="324" alt="messagePassingMailbox" src="https://user-images.githubusercontent.com/34293225/68068583-aaddd880-fd99-11e9-92d0-854db139464a.png">

      --> 커널을 표시하지는 않았지만 두가지 경우 모두 메시지를 전달하려면 중간에 OS 커널을 통해야만 전달이 가능하다.

  - shard memory : 원칙적으로 프로세스들은 각각 독자적인 주소 공간을 가지고 있어 자신의 주소 공간에만 접근할 수 있는데 shared memory에서는 일부 주소 공간을 공유할 수 있게 한 방식이다.

    ​		<img width="324" alt="sharedMemory" src="https://user-images.githubusercontent.com/34293225/68068584-add8c900-fd99-11e9-9480-1aaa6b7e7b06.png">

    - 프로세스A와 B가 서로 같은 주소 공간에 접근하기 때문에 값을 마음대로 변경하는 경우 원하지 않는 결과를 가져올 수도 있다.

  🌟 Thread는 사실상 하나의 프로세스이기 때문에 프로세스 간 협력이라고 보기는 어렵지만 동일한 프로세스를 구성하는 Thread들 끼리는 주소 공간을 공유하므로 서로 협력이 가능하다.